// 非初始化的render里，新旧children都是数组，且乱序时更优的更新算法原理和例子
// 最长递增子序列
// 贪心算法 + 二分查找
// 2 3 1 5 6 8 7 9 4

// 2
// 2 3
// 1 3
// 1 3 5
// 1 3 5 6
// 1 3 5 6 8
// 1 3 5 6 7
// 1 3 5 6 7 9
// 1 3 4 6 7 9

// 下标
// 0
// 0 1
// 2 1
// 2 1 3
// 2 1 3 4
// 2 1 3 4 5
// 2 1 3 4 6
// 2 1 3 4 6 7
// 2 1 8 4 6 7

// 追溯
// 每个数记住的是插进来时的前一位
// 9 7 6 5 3 2
// 2 3 5 6 7 9
// 所以在新children的下标为
// [0, 1, 3, 4, 6, 7]
// 在倒序插入时，跳过这些索引

// 追溯实现过程
// result = [2, 1, 8, 4, 6, 7]
// p = [0, 0, undefined, 1, 3, 4, 4, 6, 1]
// 从最后一位开始追溯(改变result)
// result = [0, 1, 3, 4, 6, 7]

// 2 3 1 5 6 8 7 9 4 5 6 7 8 9 10

// 2
// 2 3
// 1 3
// 1 3 5
// 1 3 5 6
// 1 3 5 6 8
// 1 3 5 6 7
// 1 3 5 6 7 9
// 1 3 4 6 7 9
// 1 3 4 5 7 9
// 1 3 4 5 6 9
// 1 3 4 5 6 7
// 1 3 4 5 6 7 8
// 1 3 4 5 6 7 8 9
// 1 3 4 5 6 7 8 9 10

// 例子：
// c1: a b c e f j d h
// c2: a b c d e f g k h

// e f j d
// [3, 4, 5, 6]

// d e f g k
// [6, 3, 4, 0, 0]

// 6
// 3
// 3 4
// 0 4
// 0 4

// 3 4

// 二分法例子
// 原数组
// [1, 2, 3, 4, 5, 8, 9, 10, 6]
// 到6时的结果数组
// [1, 2, 3, 4, 5, 8, 9, 10]
// [0, 1, 2, 3, 4, 5, 6, 7] // 新children混乱部分的索引(result)

// start end middle

// arrI = 6

// 索引     
// 0 7 3  4<6  start=3+1  4 7 3
// 4 7 5  8<6  end=5      4 5 5
// 4 5 4  5<6  start=4+1  5 5 4

// if arrI<start result[start]=i

// result
// [0, 1, 2, 3, 4, 8, 6, 7]

// p
// [0, 0, 1, 2, 3, 4, 5, 6]
// 经过6后变为
// [0, 0, 1, 2, 3, 4, 5, 6, 4]

// 最后追溯（改变result）
// result = [0, 1, 2, 3, 4, 5, 6, 7]